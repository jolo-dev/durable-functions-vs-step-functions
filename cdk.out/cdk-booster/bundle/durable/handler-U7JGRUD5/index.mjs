import{SESClient as Pe,SendEmailCommand as Me}from"@aws-sdk/client-ses";import{DynamoDBClient as _e,PutItemCommand as Oe}from"@aws-sdk/client-dynamodb";var Fe=new Pe({}),Ue=new _e({}),De=async r=>{console.log("send-email request",r);let{email:e,taskToken:t}=r;if(!e)throw new Error("Missing required fields: email");let n=new Date().toISOString(),a="Demo: Your Verification Code",i=Math.floor(1e5+Math.random()*9e5).toString(),o=`Here is your Code: ${i}`,l=`
    <html>
      <body style="font-family: Arial, sans-serif; text-align: center;">
        <div style="max-width: 600px; margin: 20px auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px;">
          <h2 style="color: #333;">Verification Required</h2>
          <p>Thank you for using our service. Please use the following code to continue:</p>
          <div style="background-color: #f5f5f5; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <p style="font-size: 24px; font-weight: bold; color: #007bff; margin: 0;">{ token: ${i}, email: ${e}, code: ${i} }</p>
          </div>
          <p style="font-size: 12px; color: #777;">This code is valid for 15 minutes.</p>
        </div>
      </body>
    </html>
  `;await Ue.send(new Oe({TableName:process.env.TABLE_NAME,Item:{id:{S:e},sort:{S:i},status:{S:"pending"},timestamp:{S:n}}}));let u=new Me({Source:process.env.SENDER_EMAIL,Destination:{ToAddresses:[e]},Message:{Subject:{Data:a},Body:{Text:{Data:o},Html:{Data:l}}}});try{return await Fe.send(u),{timestamp:n,taskToken:t,code:i,status:"sent"}}catch(c){throw new Error(`Failed to send email to ${e}: ${c instanceof Error?c.message:"Unknown error"}`)}};import{OperationType as w,OperationStatus as b,OperationAction as N,LambdaClient as ve,GetDurableExecutionStateCommand as We,CheckpointDurableExecutionCommand as $e}from"@aws-sdk/client-lambda";import{EventEmitter as Ie}from"events";import{AsyncLocalStorage as He}from"async_hooks";import{createHash as qe}from"crypto";import{Console as ze}from"node:console";import Se from"node:util";var k;(function(r){r.ExecutionMode="ExecutionMode",r.ReplayMode="ReplayMode",r.ReplaySucceededContext="ReplaySucceededContext"})(k||(k={}));var z;(function(r){r.SUCCEEDED="SUCCEEDED",r.FAILED="FAILED",r.PENDING="PENDING"})(z||(z={}));var y;(function(r){r.STEP="Step",r.WAIT="Wait",r.CALLBACK="Callback",r.RUN_IN_CHILD_CONTEXT="RunInChildContext",r.MAP="Map",r.MAP_ITERATION="MapIteration",r.PARALLEL="Parallel",r.PARALLEL_BRANCH="ParallelBranch",r.WAIT_FOR_CALLBACK="WaitForCallback",r.WAIT_FOR_CONDITION="WaitForCondition",r.CHAINED_INVOKE="ChainedInvoke"})(y||(y={}));var F;(function(r){r.INFO="INFO",r.WARN="WARN",r.ERROR="ERROR",r.DEBUG="DEBUG"})(F||(F={}));var j;(function(r){r.AtMostOncePerRetry="AT_MOST_ONCE_PER_RETRY",r.AtLeastOncePerRetry="AT_LEAST_ONCE_PER_RETRY"})(j||(j={}));var $;(function(r){r.NONE="NONE",r.FULL="FULL",r.HALF="HALF"})($||($={}));var R;(function(r){r.SUCCEEDED="SUCCEEDED",r.FAILED="FAILED",r.STARTED="STARTED"})(R||(R={}));var I=class{_promise=null;_executor;_isExecuted=!1;constructor(e){this._executor=e}ensureExecution(){return this._promise||(this._isExecuted=!0,this._promise=this._executor()),this._promise}then(e,t){return this.ensureExecution().then(e,t)}catch(e){return this.ensureExecution().catch(e)}finally(e){return this.ensureExecution().finally(e)}get[Symbol.toStringTag](){return"DurablePromise"}get isExecuted(){return this._isExecuted}},D;(function(r){r.EXECUTING="EXECUTING",r.RETRY_WAITING="RETRY_WAITING",r.IDLE_NOT_AWAITED="IDLE_NOT_AWAITED",r.IDLE_AWAITED="IDLE_AWAITED",r.COMPLETED="COMPLETED"})(D||(D={}));function q(r){let e="days"in r?r.days??0:0,t="hours"in r?r.hours??0:0,n="minutes"in r?r.minutes??0:0,a="seconds"in r?r.seconds??0:0;return e*24*60*60+t*60*60+n*60+a}function ee(r,e,t){return r.terminationManager.terminate({reason:e.terminationReason,message:`Unrecoverable error in step ${t}: ${e.message}`}),new Promise(()=>{})}var Ge=r=>{try{let e=new WeakSet;return JSON.stringify(r,(t,n)=>{if(typeof n=="object"&&n!==null){if(e.has(n))return"[Circular]";if(e.add(n),n instanceof Error)return{...n,name:n.name,message:n.message,stack:n.stack}}return n},2)}catch{return"[Unable to stringify]"}},h=(r,e,t)=>{process.env.DURABLE_VERBOSE_MODE==="true"&&console.debug(`${r} ${e}`,t?Ge(t):"")},Be={maxAttempts:3,initialDelay:{seconds:5},maxDelay:{minutes:5},backoffRate:2,jitter:$.FULL,retryableErrors:[/.*/],retryableErrorTypes:[]},Ke=(r,e)=>{switch(e){case $.NONE:return r;case $.FULL:return Math.random()*r;case $.HALF:return r/2+Math.random()*(r/2);default:return r}},we=(r={})=>{let e=r.retryableErrors===void 0&&r.retryableErrorTypes===void 0,t={...Be,...r,retryableErrors:r.retryableErrors??(e?[/.*/]:[])};return(n,a)=>{if(a>=t.maxAttempts)return{shouldRetry:!1};let i=t.retryableErrors.some(s=>s instanceof RegExp?s.test(n.message):n.message.includes(s)),o=t.retryableErrorTypes.some(s=>n instanceof s);if(!i&&!o)return{shouldRetry:!1};let l=q(t.initialDelay),u=q(t.maxDelay),c=Math.min(l*Math.pow(t.backoffRate,a-1),u),p=Ke(c,t.jitter);return{shouldRetry:!0,delay:{seconds:Math.max(1,Math.round(p))}}}},Ae={default:we({maxAttempts:6,initialDelay:{seconds:5},maxDelay:{seconds:60},backoffRate:2,jitter:$.FULL}),noRetry:we({maxAttempts:1})},ce=class extends Error{constructor(e,t){super("The step execution process was initiated but failed to reach completion due to an interruption."),this.name="StepInterruptedError"}},P=class extends Error{cause;errorData;stackTrace;constructor(e,t,n){super(e),this.name=this.constructor.name,this.cause=t,this.errorData=n}static fromErrorObject(e){let t=new Error(e.ErrorMessage);switch(t.name=e.ErrorType||"Error",t.stack=e.StackTrace?.join(`
`),e.ErrorType){case"StepError":return new X(e.ErrorMessage||"Step failed",t,e.ErrorData);case"CallbackError":return new U(e.ErrorMessage||"Callback failed",t,e.ErrorData);case"InvokeError":return new B(e.ErrorMessage||"Invoke failed",t,e.ErrorData);case"ChildContextError":return new v(e.ErrorMessage||"Child context failed",t,e.ErrorData);case"WaitForConditionError":return new te(e.ErrorMessage||"Wait for condition failed",t,e.ErrorData);default:return new X(e.ErrorMessage||"Unknown error",t,e.ErrorData)}}toErrorObject(){return{ErrorType:this.errorType,ErrorMessage:this.message,ErrorData:this.errorData,StackTrace:void 0}}},X=class extends P{errorType="StepError";constructor(e,t,n){super(e||"Step failed",t,n)}},U=class extends P{errorType="CallbackError";constructor(e,t,n){super(e||"Callback failed",t,n)}},B=class extends P{errorType="InvokeError";constructor(e,t,n){super(e||"Invoke failed",t,n)}},v=class extends P{errorType="ChildContextError";constructor(e,t,n){super(e||"Child context failed",t,n)}},te=class extends P{errorType="WaitForConditionError";constructor(e,t,n){super(e||"Wait for condition failed",t,n)}},H={serialize:async(r,e)=>r!==void 0?JSON.stringify(r):void 0,deserialize:async(r,e)=>r!==void 0?JSON.parse(r):void 0};var L;(function(r){r.OPERATION_TERMINATED="OPERATION_TERMINATED",r.RETRY_SCHEDULED="RETRY_SCHEDULED",r.RETRY_INTERRUPTED_STEP="RETRY_INTERRUPTED_STEP",r.WAIT_SCHEDULED="WAIT_SCHEDULED",r.CALLBACK_PENDING="CALLBACK_PENDING",r.CHECKPOINT_FAILED="CHECKPOINT_FAILED",r.SERDES_FAILED="SERDES_FAILED",r.CONTEXT_VALIDATION_ERROR="CONTEXT_VALIDATION_ERROR",r.CUSTOM="CUSTOM"})(L||(L={}));var re=class extends Error{originalError;isUnrecoverable=!0;constructor(e,t){super(e),this.originalError=t,this.name=this.constructor.name,t?.stack&&(this.stack=`${this.stack}
Caused by: ${t.stack}`)}},ne=class extends re{isUnrecoverableExecution=!0;constructor(e,t){super(`[Unrecoverable Execution] ${e}`,t)}},ae=class extends re{isUnrecoverableInvocation=!0;constructor(e,t){super(`[Unrecoverable Invocation] ${e}`,t)}};function je(r){return r instanceof Error&&"isUnrecoverable"in r&&r.isUnrecoverable===!0}function Ye(r){return r instanceof Error&&"isUnrecoverableInvocation"in r&&r.isUnrecoverableInvocation===!0}var ue=class extends ae{terminationReason=L.SERDES_FAILED;constructor(e,t){super(e||"Serdes operation failed",t)}};async function oe(r,e,t,n,a,i){try{let o={entityId:t,durableExecutionArn:i};return await r.serialize(e,o)}catch(o){let l=`Serialization failed for step ${n?`"${n}" `:""}(${t}): ${o instanceof Error?o.message:"Unknown serialization error"}`;return h("\u{1F4A5}","Serialization failed - terminating execution:",{stepId:t,stepName:n,error:o instanceof Error?o.message:String(o)}),a.terminate({reason:L.SERDES_FAILED,message:l}),new Promise(()=>{})}}async function W(r,e,t,n,a,i){try{let o={entityId:t,durableExecutionArn:i};return await r.deserialize(e,o)}catch(o){let l=`Deserialization failed for step ${n?`"${n}" `:""}(${t}): ${o instanceof Error?o.message:"Unknown deserialization error"}`;return h("\u{1F4A5}","Deserialization failed - terminating execution:",{stepId:t,stepName:n,error:o instanceof Error?o.message:String(o)}),a.terminate({reason:L.SERDES_FAILED,message:l}),new Promise(()=>{})}}var ke=new He,le=()=>ke.getStore(),V=(r,e,t,n,a)=>ke.run({contextId:r,parentId:e,attempt:n,durableExecutionMode:a},t),O=(r,e,t)=>{let n=r||"root",a=le();if(a&&a.contextId!==n){let i=`Context usage error in "${e}": You are using a parent or sibling context instead of the current child context. Expected context ID: "${a.contextId}", but got: "${r}". When inside runInChildContext(), you must use the child context parameter, not the parent context.`;t.terminate({reason:L.CONTEXT_VALIDATION_ERROR,message:i,error:new Error(i)})}};function Xe(r){return r instanceof Error||r!=null&&typeof r=="object"&&"message"in r&&"name"in r}function _(r,e){return r instanceof P?r.toErrorObject():Xe(r)?{ErrorData:e,ErrorMessage:r.message,ErrorType:r.name,StackTrace:void 0}:{ErrorData:e,ErrorMessage:"Unknown error"}}var Y=class extends ne{terminationReason=L.CUSTOM;constructor(e){super(e),this.name="NonDeterministicExecutionError"}},J=(r,e,t,n)=>{if(!(!t||!t.Type)){if(t.Type!==e.type){let a=new Y(`Non-deterministic execution detected: Operation type mismatch for step "${r}". Expected type "${t.Type}", but got "${e.type}". This indicates non-deterministic control flow in your workflow code.`);ee(n,a,r)}if(t.Name!==e.name){let a=new Y(`Non-deterministic execution detected: Operation name mismatch for step "${r}". Expected name "${t.Name??"undefined"}", but got "${e.name??"undefined"}". This indicates non-deterministic control flow in your workflow code.`);ee(n,a,r)}if(t.SubType!==e.subType){let a=new Y(`Non-deterministic execution detected: Operation subtype mismatch for step "${r}". Expected subtype "${t.SubType}", but got "${e.subType}". This indicates non-deterministic control flow in your workflow code.`);ee(n,a,r)}}},Ve=(r,e,t,n,a,i)=>(o,l,u)=>{let c,p,d;typeof o=="string"||o===void 0?(c=o,p=l,d=u):(p=o,d=l);let s=n(),E=d?.semantics||j.AtLeastOncePerRetry,f=d?.serdes||H,m=(async()=>{let g=r.getStepData(s);if(J(s,{type:w.STEP,name:c,subType:y.STEP},g,r),g?.Status===b.SUCCEEDED)return h("\u23ED\uFE0F","Step already completed:",{stepId:s}),e.markOperationState(s,D.COMPLETED,{metadata:{stepId:s,name:c,type:w.STEP,subType:y.STEP,parentId:i}}),await W(f,g.StepDetails?.Result,s,c,r.terminationManager,r.durableExecutionArn);if(g?.Status===b.FAILED)throw e.markOperationState(s,D.COMPLETED,{metadata:{stepId:s,name:c,type:w.STEP,subType:y.STEP,parentId:i}}),g.StepDetails?.Error?P.fromErrorObject(g.StepDetails.Error):new X("Unknown error");if(g?.Status===b.PENDING)return e.markOperationState(s,D.RETRY_WAITING,{metadata:{stepId:s,name:c,type:w.STEP,subType:y.STEP,parentId:i},endTimestamp:g.StepDetails?.NextAttemptTimestamp}),(async()=>(await e.waitForRetryTimer(s),g=r.getStepData(s),await x()))();if(g?.Status===b.STARTED&&E===j.AtMostOncePerRetry){let T=new ce(s,c),C=(g.StepDetails?.Attempt||0)+1,S=d?.retryStrategy?.(T,C)??Ae.default(T,C);if(!S.shouldRetry)throw await e.checkpoint(s,{Id:s,ParentId:i,Action:N.FAIL,SubType:y.STEP,Type:w.STEP,Error:_(T),Name:c}),e.markOperationState(s,D.COMPLETED),P.fromErrorObject(_(T));return await e.checkpoint(s,{Id:s,ParentId:i,Action:N.RETRY,SubType:y.STEP,Type:w.STEP,Error:_(T),Name:c,StepOptions:{NextAttemptDelaySeconds:S.delay?q(S.delay):1}}),e.markOperationState(s,D.RETRY_WAITING,{metadata:{stepId:s,name:c,type:w.STEP,subType:y.STEP,parentId:i},endTimestamp:r.getStepData(s)?.StepDetails?.NextAttemptTimestamp}),(async()=>(await e.waitForRetryTimer(s),g=r.getStepData(s),await x()))()}return await x();async function x(){g=r.getStepData(s),g?.Status!==b.STARTED&&(E===j.AtMostOncePerRetry?await e.checkpoint(s,{Id:s,ParentId:i,Action:N.START,SubType:y.STEP,Type:w.STEP,Name:c}):e.checkpoint(s,{Id:s,ParentId:i,Action:N.START,SubType:y.STEP,Type:w.STEP,Name:c}));try{g=r.getStepData(s);let T=g?.StepDetails?.Attempt||0,C={logger:a};e.markOperationState(s,D.EXECUTING,{metadata:{stepId:s,name:c,type:w.STEP,subType:y.STEP,parentId:i}});let S;S=await V(s,i,()=>p(C),T+1,k.ExecutionMode);let A=await oe(f,S,s,c,r.terminationManager,r.durableExecutionArn);return await e.checkpoint(s,{Id:s,ParentId:i,Action:N.SUCCEED,SubType:y.STEP,Type:w.STEP,Payload:A,Name:c}),e.markOperationState(s,D.COMPLETED),await W(f,A,s,c,r.terminationManager,r.durableExecutionArn)}catch(T){if(je(T))return ee(r,T,c||s);g=r.getStepData(s);let C=(g?.StepDetails?.Attempt||0)+1,S=d?.retryStrategy?.(T instanceof Error?T:new Error("Unknown Error"),C)??Ae.default(T instanceof Error?T:new Error("Unknown Error"),C);if(!S.shouldRetry)throw await e.checkpoint(s,{Id:s,ParentId:i,Action:N.FAIL,SubType:y.STEP,Type:w.STEP,Error:_(T),Name:c}),e.markOperationState(s,D.COMPLETED),P.fromErrorObject(_(T));return await e.checkpoint(s,{Id:s,ParentId:i,Action:N.RETRY,SubType:y.STEP,Type:w.STEP,Error:_(T),Name:c,StepOptions:{NextAttemptDelaySeconds:S.delay?q(S.delay):1}}),e.markOperationState(s,D.RETRY_WAITING,{metadata:{stepId:s,name:c,type:w.STEP,subType:y.STEP,parentId:i},endTimestamp:r.getStepData(s)?.StepDetails?.NextAttemptTimestamp}),await e.waitForRetryTimer(s),await x()}}})();return m.catch(()=>{}),new I(async()=>(e.markOperationAwaited(s),await m))},Je=(r,e,t,n,a)=>{function i(o,l,u,c){let p=typeof l=="string",d=p?o:void 0,s=p?l:o,E=p?u:l,f=p?c:u,m=t(),g=!1,x=(async()=>{h("\u{1F517}","Invoke phase 1:",{stepId:m,name:d||s});let T=r.getStepData(m);if(J(m,{type:w.CHAINED_INVOKE,name:d,subType:y.CHAINED_INVOKE},T,r),T?.Status===b.SUCCEEDED){h("\u23ED\uFE0F","Invoke already completed:",{stepId:m}),a?.(),e.markOperationState(m,D.COMPLETED,{metadata:{stepId:m,name:d,type:w.CHAINED_INVOKE,subType:y.CHAINED_INVOKE,parentId:n}}),g=!0;return}if(T?.Status===b.FAILED||T?.Status===b.TIMED_OUT||T?.Status===b.STOPPED){h("\u274C","Invoke already failed:",{stepId:m}),e.markOperationState(m,D.COMPLETED,{metadata:{stepId:m,name:d,type:w.CHAINED_INVOKE,subType:y.CHAINED_INVOKE,parentId:n}}),g=!0;return}if(!T){let C=await oe(f?.payloadSerdes||H,E,m,d,r.terminationManager,r.durableExecutionArn);await e.checkpoint(m,{Id:m,ParentId:n,Action:N.START,SubType:y.CHAINED_INVOKE,Type:w.CHAINED_INVOKE,Name:d,Payload:C,ChainedInvokeOptions:{FunctionName:s}})}e.markOperationState(m,D.IDLE_NOT_AWAITED,{metadata:{stepId:m,name:d,type:w.CHAINED_INVOKE,subType:y.CHAINED_INVOKE,parentId:n}}),h("\u2705","Invoke phase 1 complete:",{stepId:m})})();return x.catch(()=>{}),new I(async()=>{if(await x,g){let S=r.getStepData(m);if(S?.Status===b.SUCCEEDED){let M=S.ChainedInvokeDetails;return await W(f?.resultSerdes||H,M?.Result,m,d,r.terminationManager,r.durableExecutionArn)}let A=S?.ChainedInvokeDetails;throw A?.Error?new B(A.Error.ErrorMessage||"Invoke failed",A.Error.ErrorMessage?new Error(A.Error.ErrorMessage):void 0,A.Error.ErrorData):new B("Invoke failed")}h("\u{1F517}","Invoke phase 2:",{stepId:m}),e.markOperationAwaited(m),await e.waitForStatusChange(m);let T=r.getStepData(m);if(T?.Status===b.SUCCEEDED){h("\u2705","Invoke completed:",{stepId:m}),a?.(),e.markOperationState(m,D.COMPLETED);let S=T.ChainedInvokeDetails;return await W(f?.resultSerdes||H,S?.Result,m,d,r.terminationManager,r.durableExecutionArn)}h("\u274C","Invoke failed:",{stepId:m,status:T?.Status}),e.markOperationState(m,D.COMPLETED);let C=T?.ChainedInvokeDetails;throw C?.Error?new B(C.Error.ErrorMessage||"Invoke failed",C.Error.ErrorMessage?new Error(C.Error.ErrorMessage):void 0,C.Error.ErrorData):new B("Invoke failed")})}return i},be=256*1024,Qe=(r,e)=>{let t=r.getStepData(e);return t?t.Status===b.SUCCEEDED&&t.ContextDetails?.ReplayChildren?k.ReplaySucceededContext:t.Status===b.SUCCEEDED||t.Status===b.FAILED?k.ReplayMode:k.ExecutionMode:k.ExecutionMode},Ze=(r,e,t,n,a,i,o)=>(l,u,c)=>{let p,d,s;typeof l=="string"||l===void 0?(p=l,d=u,s=c):(d=l,s=u);let E=n();h("\u{1F504}","Running child context:",{entityId:E,name:p});let f=r.getStepData(E);J(E,{type:w.CONTEXT,name:p,subType:s?.subType||y.RUN_IN_CHILD_CONTEXT},f,r);let m,g,x=(async()=>{let T=r.getStepData(E);return T?.Status===b.SUCCEEDED||T?.Status===b.FAILED?(e.markAncestorFinished(E),et(r,t,E,p,d,s,a,i)):tt(r,e,t,E,p,d,s,a,i,o)})().then(T=>{m=T}).catch(T=>{g=T});return new I(async()=>{if(await x,g!==void 0)throw g;return m})},et=async(r,e,t,n,a,i,o,l)=>{let u=i?.serdes||H,c=r.getStepData(t),p=c?.ContextDetails?.Result;if(c?.Status===b.FAILED)if(c.ContextDetails?.Error){let d=P.fromErrorObject(c.ContextDetails.Error);throw new v(d.message,d)}else throw new v("Child context failed");if(c?.ContextDetails?.ReplayChildren){h("\u{1F504}","ReplayChildren mode: Re-executing child context due to large payload:",{entityId:t,stepName:n});let d=l(r,e,k.ReplaySucceededContext,o(),t,void 0,t);return await V(t,t,()=>a(d))}return h("\u23ED\uFE0F","Child context already finished, returning cached result:",{entityId:t}),await W(u,p,t,n,r.terminationManager,r.durableExecutionArn)},tt=async(r,e,t,n,a,i,o,l,u,c)=>{let p=o?.serdes||H;if(r.getStepData(n)===void 0){let E=o?.subType||y.RUN_IN_CHILD_CONTEXT;e.checkpoint(n,{Id:n,ParentId:c,Action:N.START,SubType:E,Type:w.CONTEXT,Name:a})}let d=Qe(r,n),s=u(r,t,d,l(),n,void 0,n);try{let E=await V(n,c,()=>i(s),void 0,d),f=await oe(p,E,n,a,r.terminationManager,r.durableExecutionArn),m=f,g=!1;f&&Buffer.byteLength(f,"utf8")>be&&(g=!0,o?.summaryGenerator?m=o.summaryGenerator(E):m="",h("\u{1F4E6}","Large payload detected, using ReplayChildren mode:",{entityId:n,name:a,payloadSize:Buffer.byteLength(f,"utf8"),limit:be})),e.markAncestorFinished(n);let x=o?.subType||y.RUN_IN_CHILD_CONTEXT;return e.checkpoint(n,{Id:n,ParentId:c,Action:N.SUCCEED,SubType:x,Type:w.CONTEXT,Payload:m,ContextOptions:g?{ReplayChildren:!0}:void 0,Name:a}),h("\u2705","Child context completed successfully:",{entityId:n,name:a}),E}catch(E){h("\u274C","Child context failed:",{entityId:n,name:a,error:E}),e.markAncestorFinished(n);let f=o?.subType||y.RUN_IN_CHILD_CONTEXT;e.checkpoint(n,{Id:n,ParentId:c,Action:N.FAIL,SubType:f,Type:w.CONTEXT,Error:_(E),Name:a});let m=_(E),g=P.fromErrorObject(m);throw new v(g.message,g)}},rt=(r,e,t,n,a)=>{function i(o,l){let u=typeof o=="string",c=u?o:void 0,d=q(u?l:o),s=t(),E=!1,f=(async()=>{h("\u23F2\uFE0F","Wait phase 1:",{stepId:s,name:c,seconds:d});let m=r.getStepData(s);if(J(s,{type:w.WAIT,name:c,subType:y.WAIT},m,r),m?.Status===b.SUCCEEDED){h("\u23ED\uFE0F","Wait already completed:",{stepId:s}),a?.(),e.markOperationState(s,D.COMPLETED,{metadata:{stepId:s,name:c,type:w.WAIT,subType:y.WAIT,parentId:n}}),E=!0;return}m||await e.checkpoint(s,{Id:s,ParentId:n,Action:N.START,SubType:y.WAIT,Type:w.WAIT,Name:c,WaitOptions:{WaitSeconds:d}}),m=r.getStepData(s),e.markOperationState(s,D.IDLE_NOT_AWAITED,{metadata:{stepId:s,name:c,type:w.WAIT,subType:y.WAIT,parentId:n},endTimestamp:m?.WaitDetails?.ScheduledEndTimestamp}),h("\u2705","Wait phase 1 complete:",{stepId:s})})();return f.catch(()=>{}),new I(async()=>{if(await f,E)return;h("\u23F2\uFE0F","Wait phase 2:",{stepId:s}),e.markOperationAwaited(s),await e.waitForStatusChange(s);let m=r.getStepData(s);if(m?.Status===b.SUCCEEDED){h("\u2705","Wait completed:",{stepId:s}),a?.(),e.markOperationState(s,D.COMPLETED);return}h("\u26A0\uFE0F","Wait ended with unexpected status:",{stepId:s,status:m?.Status})})}return i},nt=(r,e,t,n,a)=>(i,o,l)=>{let u,c,p;if(typeof i=="string"||i===void 0?(u=i,c=o,p=l):(c=i,p=o),!p?.waitStrategy||p.initialState===void 0)throw new Error("waitForCondition requires config with waitStrategy and initialState");let d=t(),s=p.serdes||H,E=(async()=>{let f=r.getStepData(d);if(f?.Status===b.SUCCEEDED)return h("\u23ED\uFE0F","WaitForCondition already completed:",{stepId:d}),e.markOperationState(d,D.COMPLETED,{metadata:{stepId:d,name:u,type:w.STEP,subType:y.WAIT_FOR_CONDITION,parentId:a}}),await W(s,f.StepDetails?.Result,d,u,r.terminationManager,r.durableExecutionArn);if(f?.Status===b.FAILED)throw e.markOperationState(d,D.COMPLETED,{metadata:{stepId:d,name:u,type:w.STEP,subType:y.WAIT_FOR_CONDITION,parentId:a}}),f.StepDetails?.Error?P.fromErrorObject(f.StepDetails.Error):new te("waitForCondition failed");if(f?.Status===b.PENDING)return e.markOperationState(d,D.RETRY_WAITING,{metadata:{stepId:d,name:u,type:w.STEP,subType:y.WAIT_FOR_CONDITION,parentId:a},endTimestamp:f.StepDetails?.NextAttemptTimestamp}),(async()=>(await e.waitForRetryTimer(d),f=r.getStepData(d),await m()))();return await m();async function m(){f=r.getStepData(d);let g;if(f?.Status===b.STARTED||f?.Status===b.READY){let T=f.StepDetails?.Result;if(T)try{let C={entityId:d,durableExecutionArn:r.durableExecutionArn};g=await s.deserialize(T,C)}catch{g=p.initialState}else g=p.initialState}else g=p.initialState;let x=(f?.StepDetails?.Attempt??0)+1;f?.Status!==b.STARTED&&e.checkpoint(d,{Id:d,ParentId:a,Action:N.START,SubType:y.WAIT_FOR_CONDITION,Type:w.STEP,Name:u});try{let T={logger:n};e.markOperationState(d,D.EXECUTING,{metadata:{stepId:d,name:u,type:w.STEP,subType:y.WAIT_FOR_CONDITION,parentId:a}});let C=await V(d,a,()=>c(g,T),x,k.ExecutionMode),S=await oe(s,C,d,u,r.terminationManager,r.durableExecutionArn),A=await W(s,S,d,u,r.terminationManager,r.durableExecutionArn),M=p.waitStrategy(A,x);return M.shouldContinue?(await e.checkpoint(d,{Id:d,ParentId:a,Action:N.RETRY,SubType:y.WAIT_FOR_CONDITION,Type:w.STEP,Payload:S,Name:u,StepOptions:{NextAttemptDelaySeconds:q(M.delay)}}),e.markOperationState(d,D.RETRY_WAITING,{metadata:{stepId:d,name:u,type:w.STEP,subType:y.WAIT_FOR_CONDITION,parentId:a},endTimestamp:r.getStepData(d)?.StepDetails?.NextAttemptTimestamp}),await e.waitForRetryTimer(d),await m()):(await e.checkpoint(d,{Id:d,ParentId:a,Action:N.SUCCEED,SubType:y.WAIT_FOR_CONDITION,Type:w.STEP,Payload:S,Name:u}),e.markOperationState(d,D.COMPLETED),A)}catch(T){throw await e.checkpoint(d,{Id:d,ParentId:a,Action:N.FAIL,SubType:y.WAIT_FOR_CONDITION,Type:w.STEP,Error:_(T),Name:u}),e.markOperationState(d,D.COMPLETED),P.fromErrorObject(_(T))}}})();return E.catch(()=>{}),new I(async()=>(e.markOperationAwaited(d),await E))},at=(r,e,t,n,a,i)=>new I(async()=>{h("\u{1F504}","Callback promise phase 2:",{stepId:t,stepName:n}),e.markOperationAwaited(t),await e.waitForStatusChange(t);let o=r.getStepData(t);if(o?.Status===b.SUCCEEDED){h("\u2705","Callback completed:",{stepId:t}),i(),e.markOperationState(t,D.COMPLETED);let c=o.CallbackDetails;if(!c)throw new U(`No callback data found for completed callback: ${t}`);return await W(a,c.Result,t,n,r.terminationManager,r.durableExecutionArn)}h("\u274C","Callback failed:",{stepId:t,status:o?.Status}),e.markOperationState(t,D.COMPLETED);let u=o?.CallbackDetails?.Error;if(u){let c=new Error(u.ErrorMessage);throw c.name=u.ErrorType||"Error",c.stack=u.StackTrace?.join(`
`),new U(u.ErrorMessage||"Callback failed",c,u.ErrorData)}throw new U("Callback failed")}),Re=()=>({serialize:async r=>r,deserialize:async r=>r}),it=(r,e,t,n,a)=>(i,o)=>{let l,u;typeof i=="string"||i===void 0?(l=i,u=o):u=i;let c=t(),p=u?.serdes||Re(),d=!1,s=(async()=>{h("\u{1F4DE}","Callback phase 1:",{stepId:c,name:l});let E=r.getStepData(c);if(J(c,{type:w.CALLBACK,name:l,subType:y.CALLBACK},E,r),E?.Status===b.SUCCEEDED){h("\u23ED\uFE0F","Callback already completed:",{stepId:c}),n(),e.markOperationState(c,D.COMPLETED,{metadata:{stepId:c,name:l,type:w.CALLBACK,subType:y.CALLBACK,parentId:a}}),d=!0;return}if(E?.Status===b.FAILED||E?.Status===b.TIMED_OUT){h("\u274C","Callback already failed:",{stepId:c}),e.markOperationState(c,D.COMPLETED,{metadata:{stepId:c,name:l,type:w.CALLBACK,subType:y.CALLBACK,parentId:a}}),d=!0;return}E||(await e.checkpoint(c,{Id:c,ParentId:a,Action:"START",SubType:y.CALLBACK,Type:w.CALLBACK,Name:l,CallbackOptions:{TimeoutSeconds:u?.timeout?q(u.timeout):void 0,HeartbeatTimeoutSeconds:u?.heartbeatTimeout?q(u.heartbeatTimeout):void 0}}),E=r.getStepData(c)),e.markOperationState(c,D.IDLE_NOT_AWAITED,{metadata:{stepId:c,name:l,type:w.CALLBACK,subType:y.CALLBACK,parentId:a}}),h("\u2705","Callback phase 1 complete:",{stepId:c})})();return s.catch(()=>{}),new I(async()=>{if(await s,d){let x=r.getStepData(c),T=x?.CallbackDetails;if(!T?.CallbackId)throw new U(`No callback ID found for callback: ${c}`);if(x?.Status===b.SUCCEEDED){let M=await W(p,T.Result,c,l,r.terminationManager,r.durableExecutionArn);return[new I(async()=>M),T.CallbackId]}let C=x?.CallbackDetails?.Error,S=C?(()=>{let M=new Error(C.ErrorMessage);return M.name=C.ErrorType||"Error",M.stack=C.StackTrace?.join(`
`),new U(C.ErrorMessage||"Callback failed",M,C.ErrorData)})():new U("Callback failed");return[new I(async()=>{throw S}),T.CallbackId]}h("\u{1F4DE}","Callback phase 2:",{stepId:c});let f=r.getStepData(c)?.CallbackDetails;if(!f?.CallbackId)throw new U(`No callback ID found for started callback: ${c}`);let m=f.CallbackId,g=at(r,e,c,l,p,n);return h("\u2705","Callback created:",{stepId:c,name:l,callbackId:m}),[g,m]})},ot=(r,e,t)=>(n,a,i)=>{let o,l,u;if(typeof n=="string"||n===void 0)if(o=n,typeof a=="function")l=a,u=i;else return new I(()=>Promise.reject(new Error("waitForCallback requires a submitter function when name is provided")));else if(typeof n=="function")l=n,u=a;else return new I(()=>Promise.reject(new Error("waitForCallback requires a submitter function")));let c=(async()=>{h("\u{1F4DE}","WaitForCallback requested:",{name:o,hasSubmitter:!!l,config:u});let p=async s=>{let E=u?{timeout:u.timeout,heartbeatTimeout:u.heartbeatTimeout}:void 0,[f,m]=await s.createCallback(E);return h("\u{1F194}","Callback created:",{callbackId:m,name:o}),await s.step(async g=>{let x={logger:g.logger};h("\u{1F4E4}","Executing submitter:",{callbackId:m,name:o}),await l(m,x),h("\u2705","Submitter completed:",{callbackId:m,name:o})},u?.retryStrategy?{retryStrategy:u.retryStrategy}:void 0),h("\u23F3","Waiting for callback completion:",{callbackId:m,name:o}),await f},d=e();return{result:await t(o,p,{subType:y.WAIT_FOR_CALLBACK}),stepId:d}})();return c.catch(()=>{}),new I(async()=>{let{result:p,stepId:d}=await c;return await W(u?.serdes??Re(),p,d,o,r.terminationManager,r.durableExecutionArn)})},st=()=>r=>JSON.stringify({type:"ParallelResult",totalCount:r.totalCount,successCount:r.successCount,failureCount:r.failureCount,startedCount:r.startedCount,completionReason:r.completionReason,status:r.status}),ct=()=>r=>JSON.stringify({type:"MapResult",totalCount:r.totalCount,successCount:r.successCount,failureCount:r.failureCount,completionReason:r.completionReason,status:r.status}),ut=(r,e)=>(t,n,a,i)=>{let o=(async()=>{let l,u,c,p;if(typeof t=="string"||t===void 0?(l=t,u=n,c=a,p=i):(u=t,c=n,p=a),h("\u{1F5FA}\uFE0F","Starting map operation:",{name:l,itemCount:u.length,maxConcurrency:p?.maxConcurrency}),!Array.isArray(u))throw new Error("Map operation requires an array of items");if(typeof c!="function")throw new Error("Map operation requires a function to process items");let d=u.map((f,m)=>({id:`map-item-${m}`,data:f,index:m,name:p?.itemNamer?p.itemNamer(f,m):void 0})),E=await e(l,d,async(f,m)=>c(m,f.data,f.index,u),{maxConcurrency:p?.maxConcurrency,topLevelSubType:y.MAP,iterationSubType:y.MAP_ITERATION,summaryGenerator:ct(),completionConfig:p?.completionConfig,serdes:p?.serdes,itemSerdes:p?.itemSerdes});return h("\u{1F5FA}\uFE0F","Map operation completed successfully:",{resultCount:E.totalCount}),E})();return o.catch(()=>{}),new I(async()=>await o)},lt=(r,e)=>(t,n,a)=>{let i=(async()=>{let o,l,u;if(typeof t=="string"||t===void 0?(o=t,l=n,u=a):(l=t,u=n),!Array.isArray(l))throw new Error("Parallel operation requires an array of branch functions");if(h("\u{1F500}","Starting parallel operation:",{name:o,branchCount:l.length,maxConcurrency:u?.maxConcurrency}),l.some(s=>typeof s!="function"&&(typeof s!="object"||typeof s.func!="function")))throw new Error("All branches must be functions or NamedParallelBranch objects");let c=l.map((s,E)=>{let f=typeof s=="object"&&"func"in s,m=f?s.func:s,g=f?s.name:void 0;return{id:`parallel-branch-${E}`,data:m,index:E,name:g}}),d=await e(o,c,async(s,E)=>{h("\u{1F500}","Processing parallel branch:",{index:s.index});let f=await s.data(E);return h("\u2705","Parallel branch completed:",{index:s.index,result:f}),f},{maxConcurrency:u?.maxConcurrency,topLevelSubType:y.PARALLEL,iterationSubType:y.PARALLEL_BRANCH,summaryGenerator:st(),completionConfig:u?.completionConfig,serdes:u?.serdes,itemSerdes:u?.itemSerdes});return h("\u{1F500}","Parallel operation completed successfully:",{resultCount:d.totalCount}),d})();return i.catch(()=>{}),new I(async()=>await i)};function dt(r){return r.map(e=>e&&e.status==="rejected"&&e.reason instanceof Error?{...e,reason:{message:e.reason.message,name:e.reason.name,stack:e.reason.stack}}:e)}function ht(r){return r.map(e=>{if(e&&e.status==="rejected"&&e.reason&&typeof e.reason=="object"&&e.reason.message){let t=new Error(e.reason.message);return t.name=e.reason.name||"Error",e.reason.stack&&(t.stack=e.reason.stack),{...e,reason:t}}return e})}function mt(){return{serialize:async(r,e)=>r!==void 0?JSON.stringify(dt(r)):void 0,deserialize:async(r,e)=>r!==void 0?ht(JSON.parse(r)):void 0}}var Q={retryStrategy:()=>({shouldRetry:!1})},pt=r=>{let e=(o,l)=>typeof o=="string"||o===void 0?{name:o,promises:l}:{name:void 0,promises:o};return{all:(o,l)=>new I(async()=>{let{name:u,promises:c}=e(o,l);return await r(u,()=>Promise.all(c),Q)}),allSettled:(o,l)=>new I(async()=>{let{name:u,promises:c}=e(o,l);return await r(u,()=>Promise.allSettled(c),{...Q,serdes:mt()})}),any:(o,l)=>new I(async()=>{let{name:u,promises:c}=e(o,l);return await r(u,()=>Promise.any(c),Q)}),race:(o,l)=>new I(async()=>{let{name:u,promises:c}=e(o,l);return await r(u,()=>Promise.race(c),Q)})}},K=class{all;completionReason;constructor(e,t){this.all=e,this.completionReason=t}succeeded(){return this.all.filter(e=>e.status===R.SUCCEEDED&&e.result!==void 0)}failed(){return this.all.filter(e=>e.status===R.FAILED&&e.error!==void 0)}started(){return this.all.filter(e=>e.status===R.STARTED)}get status(){return this.hasFailure?R.FAILED:R.SUCCEEDED}get hasFailure(){return this.all.some(e=>e.status===R.FAILED)}throwIfError(){let e=this.all.find(t=>t.status===R.FAILED)?.error;if(e)throw e}getResults(){return this.succeeded().map(e=>e.result)}getErrors(){return this.failed().map(e=>e.error)}get successCount(){return this.all.filter(e=>e.status===R.SUCCEEDED).length}get failureCount(){return this.all.filter(e=>e.status===R.FAILED).length}get startedCount(){return this.all.filter(e=>e.status===R.STARTED).length}get totalCount(){return this.all.length}};function Et(r){if(r&&typeof r=="object"&&"all"in r&&Array.isArray(r.all)){let e=r,t=e.all.map(n=>({...n,result:n.result,error:n.error?P.fromErrorObject(n.error):void 0}));return new K(t,e.completionReason)}return new K([],"ALL_COMPLETED")}var de=class{operationName;skipNextOperation;constructor(e,t){this.operationName=e,this.skipNextOperation=t}isChildEntityCompleted(e,t,n){let a=`${t}-${n+1}`,i=e.getStepData(a);return!!(i&&(i.Status===b.SUCCEEDED||i.Status===b.FAILED))}getCompletionReason(e,t,n,a,i){let o=i.completionConfig;if(o){if(Object.values(o).some(u=>u!==void 0)){if(o.toleratedFailureCount!==void 0&&e>o.toleratedFailureCount||o.toleratedFailurePercentage!==void 0&&e/a.length*100>o.toleratedFailurePercentage)return"FAILURE_TOLERANCE_EXCEEDED"}else if(e>0)return"FAILURE_TOLERANCE_EXCEEDED"}else if(e>0)return"FAILURE_TOLERANCE_EXCEEDED";return n===a.length?"ALL_COMPLETED":i.completionConfig?.minSuccessful!==void 0&&t>=i.completionConfig.minSuccessful?"MIN_SUCCESSFUL_REACHED":"ALL_COMPLETED"}async executeItems(e,t,n,a,i=k.ExecutionMode,o,l){if(i===k.ReplaySucceededContext){h("\u{1F504}",`Replay mode: Reconstructing ${this.operationName} result:`,{itemCount:e.length});let u;if(o&&l){let p=l.getStepData(o)?.ContextDetails?.Result;if(p)try{let s=await(a.serdes||H).deserialize(p,{entityId:o,durableExecutionArn:l.durableExecutionArn});s&&typeof s=="object"&&"totalCount"in s&&(u=s.totalCount,h("\u{1F4CA}","Found initial execution count:",{targetTotalCount:u}))}catch(d){h("\u26A0\uFE0F","Could not parse initial result summary:",d)}}if(u!==void 0&&o&&l)return await this.replayItems(e,t,n,a,u,l,o);h("\u26A0\uFE0F","No valid target count or context found, falling back to concurrent execution")}return await this.executeItemsConcurrently(e,t,n,a)}async replayItems(e,t,n,a,i,o,l){let u=[];h("\u{1F504}",`Replaying ${e.length} items sequentially`,{targetTotalCount:i});let c=0,p=0;for(let E of e){if(c>=i){h("\u2705","Reached target count, stopping replay",{completedCount:c,targetTotalCount:i});break}let f=`${l}-${p+1}`;if(!this.isChildEntityCompleted(o,l,p)){h("\u23ED\uFE0F","Skipping incomplete item:",{index:E.index,itemId:E.id,childEntityId:f}),this.skipNextOperation(),p++;continue}try{let m=await n.runInChildContext(E.name||E.id,g=>t(E,g),{subType:a.iterationSubType,serdes:a.itemSerdes});u.push({result:m,index:E.index,status:R.SUCCEEDED}),c++,p++,h("\u2705",`Replayed ${this.operationName} item:`,{index:E.index,itemId:E.id,completedCount:c})}catch(m){let g=m instanceof v?m:new v(m instanceof Error?m.message:String(m),m instanceof Error?m:void 0);u.push({error:g,index:E.index,status:R.FAILED}),c++,p++,h("\u274C",`Replay failed for ${this.operationName} item:`,{index:E.index,itemId:E.id,error:g.message,completedCount:c})}}h("\u{1F389}",`${this.operationName} replay completed:`,{completedCount:c,totalCount:u.length});let d=u.filter(E=>E.status===R.SUCCEEDED).length,s=c-d;return new K(u,this.getCompletionReason(s,d,c,e,a))}async executeItemsConcurrently(e,t,n,a){let i=a.maxConcurrency||1/0,o=new Array(e.length),l=new Set,u=0,c=0,p=0,d=0,s=0;return h("\u{1F680}",`Starting ${this.operationName} with concurrency control:`,{itemCount:e.length,maxConcurrency:i}),new Promise(E=>{let f=()=>{let C=a.completionConfig;return!C||!Object.values(C).some(A=>A!==void 0)?s===0:!(C.toleratedFailureCount!==void 0&&s>C.toleratedFailureCount||C.toleratedFailurePercentage!==void 0&&s/e.length*100>C.toleratedFailurePercentage)},m=()=>{if(p===e.length)return!0;let C=a.completionConfig;return C?.minSuccessful!==void 0&&d>=C.minSuccessful},g=C=>this.getCompletionReason(C,d,p,e,a),x=()=>{for(;u<i&&c<e.length&&f();){let C=c++,S=e[C];l.add(C),u++,o[C]={index:C,status:R.STARTED},h("\u25B6\uFE0F",`Starting ${this.operationName} item:`,{index:C,itemId:S.id,itemName:S.name}),n.runInChildContext(S.name||S.id,A=>t(S,A),{subType:a.iterationSubType,serdes:a.itemSerdes}).then(A=>{o[C]={result:A,index:C,status:R.SUCCEEDED},d++,h("\u2705",`${this.operationName} item completed:`,{index:C,itemId:S.id,itemName:S.name}),T()},A=>{let M=A instanceof v?A:new v(A instanceof Error?A.message:String(A),A instanceof Error?A:void 0);o[C]={error:M,index:C,status:R.FAILED},s++,h("\u274C",`${this.operationName} item failed:`,{index:C,itemId:S.id,itemName:S.name,error:M.message}),T()})}},T=()=>{if(u--,p++,m()||!f()){let C=[];for(let A=0;A<o.length;A++)o[A]!==void 0&&C.push({...o[A]});h("\u{1F389}",`${this.operationName} completed:`,{successCount:d,failureCount:s,startedCount:C.filter(A=>A.status===R.STARTED).length,totalCount:C.length});let S=new K(C,g(s));E(S)}else x()};x()})}},ft=(r,e,t)=>(n,a,i,o)=>{let l=(async()=>{let u,c,p,d;if(typeof n=="string"||n===void 0?(u=n,c=a,p=i,d=o):(c=n,p=a,d=i),h("\u{1F504}","Starting concurrent execution:",{name:u,itemCount:c.length,maxConcurrency:d?.maxConcurrency}),!Array.isArray(c))throw new Error("Concurrent execution requires an array of items");if(typeof p!="function")throw new Error("Concurrent execution requires an executor function");if(d?.maxConcurrency!==void 0&&d.maxConcurrency!==null&&d.maxConcurrency<=0)throw new Error(`Invalid maxConcurrency: ${d.maxConcurrency}. Must be a positive number or undefined for unlimited concurrency.`);let E=await e(u,async f=>{let m=new de("concurrent-execution",t),g=f.durableExecutionMode,x=f._stepPrefix;return h("\u{1F504}","Concurrent execution mode:",{mode:g,itemCount:c.length,entityId:x}),await m.executeItems(c,p,f,d||{},g,x,r)},{subType:d?.topLevelSubType,summaryGenerator:d?.summaryGenerator,serdes:d?.serdes});return E&&typeof E=="object"&&"all"in E&&Array.isArray(E.all)?Et(E):E})();return l.catch(()=>{}),new I(async()=>await l)},he=class{captureExecutionState;checkAndUpdateReplayMode;checkForNonResolvingPromise;getDurableExecutionMode;setDurableExecutionMode;constructor(e,t,n,a,i){this.captureExecutionState=e,this.checkAndUpdateReplayMode=t,this.checkForNonResolvingPromise=n,this.getDurableExecutionMode=a,this.setDurableExecutionMode=i}withModeManagement(e){let t=this.captureExecutionState();this.checkAndUpdateReplayMode();let n=this.checkForNonResolvingPromise();if(n)return n;try{return e()}finally{t&&this.setDurableExecutionMode(k.ExecutionMode)}}withDurableModeManagement(e){let t=this.captureExecutionState();this.checkAndUpdateReplayMode();let n=this.checkForNonResolvingPromise();if(n)return new I(async()=>{throw await n,new Error("Unreachable code")});try{return e()}finally{t&&this.setDurableExecutionMode(k.ExecutionMode)}}},gt=16,G=r=>qe("md5").update(r).digest("hex").substring(0,gt),Ct=(r,e)=>{let t=G(e);return r[t]},me=class{executionContext;lambdaContext;_stepPrefix;_stepCounter=0;durableLogger;modeAwareLoggingEnabled=!0;checkpoint;durableExecutionMode;_parentId;modeManagement;durableExecution;logger;constructor(e,t,n,a,i,o,l){this.executionContext=e,this.lambdaContext=t,this._stepPrefix=i,this._parentId=l,this.durableExecution=o,this.durableLogger=a,this.durableLogger.configureDurableLoggingContext?.(this.getDurableLoggingContext()),this.logger=this.createModeAwareLogger(a),this.durableExecutionMode=n,this.checkpoint=o.checkpointManager,this.modeManagement=new he(this.captureExecutionState.bind(this),this.checkAndUpdateReplayMode.bind(this),this.checkForNonResolvingPromise.bind(this),()=>this.durableExecutionMode,u=>{this.durableExecutionMode=u})}getDurableLoggingContext(){return{getDurableLogData:()=>{let e=le(),t={executionArn:this.executionContext.durableExecutionArn,requestId:this.executionContext.requestId,tenantId:this.executionContext.tenantId,operationId:!e||e?.contextId==="root"?void 0:G(e.contextId)};return e?.attempt!==void 0&&(t.attempt=e.attempt),t}}}shouldLog(){let e=le();return!this.modeAwareLoggingEnabled||!e?!0:e.contextId==="root"?this.durableExecutionMode===k.ExecutionMode:e.durableExecutionMode===k.ExecutionMode}createModeAwareLogger(e){let t={warn:(...n)=>{if(this.shouldLog())return e.warn(...n)},debug:(...n)=>{if(this.shouldLog())return e.debug(...n)},info:(...n)=>{if(this.shouldLog())return e.info(...n)},error:(...n)=>{if(this.shouldLog())return e.error(...n)}};return"log"in e&&(t.log=(n,...a)=>{if(this.shouldLog())return e.log?.(n,...a)}),t}createStepId(){return this._stepCounter++,this._stepPrefix?`${this._stepPrefix}-${this._stepCounter}`:`${this._stepCounter}`}getNextStepId(){let e=this._stepCounter+1;return this._stepPrefix?`${this._stepPrefix}-${e}`:`${e}`}skipNextOperation(){this._stepCounter++}checkAndUpdateReplayMode(){if(this.durableExecutionMode===k.ReplayMode){let e=this.getNextStepId();this.executionContext.getStepData(e)||(this.durableExecutionMode=k.ExecutionMode)}}captureExecutionState(){let e=this.durableExecutionMode===k.ReplayMode,t=this.getNextStepId(),n=this.executionContext.getStepData(t),a=!!(n&&n.Status!==b.SUCCEEDED&&n.Status!==b.FAILED);return e&&a}checkForNonResolvingPromise(){if(this.durableExecutionMode===k.ReplaySucceededContext){let e=this.getNextStepId(),t=this.executionContext.getStepData(e);if(t&&t.Status!==b.SUCCEEDED&&t.Status!==b.FAILED)return new Promise(()=>{})}return null}withModeManagement(e){return this.modeManagement.withModeManagement(e)}withDurableModeManagement(e){return this.modeManagement.withDurableModeManagement(e)}step(e,t,n){return O(this._stepPrefix,"step",this.executionContext.terminationManager),this.withDurableModeManagement(()=>Ve(this.executionContext,this.checkpoint,this.lambdaContext,this.createStepId.bind(this),this.durableLogger,this._parentId)(e,t,n))}invoke(e,t,n,a){return O(this._stepPrefix,"invoke",this.executionContext.terminationManager),this.withDurableModeManagement(()=>Je(this.executionContext,this.checkpoint,this.createStepId.bind(this),this._parentId,this.checkAndUpdateReplayMode.bind(this))(e,t,n,a))}runInChildContext(e,t,n){return O(this._stepPrefix,"runInChildContext",this.executionContext.terminationManager),this.withDurableModeManagement(()=>Ze(this.executionContext,this.checkpoint,this.lambdaContext,this.createStepId.bind(this),()=>this.durableLogger,(i,o,l,u,c,p,d)=>Le(i,o,l,u,c,this.durableExecution,d),this._parentId)(e,t,n))}wait(e,t){return O(this._stepPrefix,"wait",this.executionContext.terminationManager),this.withDurableModeManagement(()=>{let n=rt(this.executionContext,this.checkpoint,this.createStepId.bind(this),this._parentId,this.checkAndUpdateReplayMode.bind(this));return typeof e=="string"?n(e,t):n(e)})}configureLogger(e){e.customLogger!==void 0&&(this.durableLogger=e.customLogger,this.durableLogger.configureDurableLoggingContext?.(this.getDurableLoggingContext()),this.logger=this.createModeAwareLogger(this.durableLogger)),e.modeAware!==void 0&&(this.modeAwareLoggingEnabled=e.modeAware)}createCallback(e,t){return O(this._stepPrefix,"createCallback",this.executionContext.terminationManager),this.withDurableModeManagement(()=>it(this.executionContext,this.checkpoint,this.createStepId.bind(this),this.checkAndUpdateReplayMode.bind(this),this._parentId)(e,t))}waitForCallback(e,t,n){return O(this._stepPrefix,"waitForCallback",this.executionContext.terminationManager),this.withDurableModeManagement(()=>ot(this.executionContext,this.getNextStepId.bind(this),this.runInChildContext.bind(this))(e,t,n))}waitForCondition(e,t,n){return O(this._stepPrefix,"waitForCondition",this.executionContext.terminationManager),this.withDurableModeManagement(()=>{let a=nt(this.executionContext,this.checkpoint,this.createStepId.bind(this),this.durableLogger,this._parentId);return typeof e=="string"||e===void 0?a(e,t,n):a(e,t)})}map(e,t,n,a){return O(this._stepPrefix,"map",this.executionContext.terminationManager),this.withDurableModeManagement(()=>ut(this.executionContext,this._executeConcurrently.bind(this))(e,t,n,a))}parallel(e,t,n){return O(this._stepPrefix,"parallel",this.executionContext.terminationManager),this.withDurableModeManagement(()=>lt(this.executionContext,this._executeConcurrently.bind(this))(e,t,n))}_executeConcurrently(e,t,n,a){return O(this._stepPrefix,"_executeConcurrently",this.executionContext.terminationManager),this.withDurableModeManagement(()=>{let o=ft(this.executionContext,this.runInChildContext.bind(this),this.skipNextOperation.bind(this))(e,t,n,a);return o?.catch(()=>{}),o})}get promise(){return pt(this.step.bind(this))}},Le=(r,e,t,n,a,i,o)=>new me(r,e,t,n,a,i,o),ie=class extends ae{terminationReason=L.CHECKPOINT_FAILED;constructor(e,t){super(e||"Checkpoint operation failed",t)}},pe=class extends ne{terminationReason=L.CHECKPOINT_FAILED;constructor(e,t){super(e||"Checkpoint operation failed",t)}},Tt="stepDataUpdated",Ee=class r{durableExecutionArn;stepData;storage;terminationManager;stepDataEmitter;logger;finishedAncestors;queue=[];isProcessing=!1;currentTaskToken;forceCheckpointPromises=[];queueCompletionResolver=null;MAX_PAYLOAD_SIZE=750*1024;isTerminating=!1;static textEncoder=new TextEncoder;operations=new Map;terminationTimer=null;terminationReason=null;TERMINATION_COOLDOWN_MS=50;constructor(e,t,n,a,i,o,l,u){this.durableExecutionArn=e,this.stepData=t,this.storage=n,this.terminationManager=a,this.stepDataEmitter=o,this.logger=l,this.finishedAncestors=u,this.currentTaskToken=i}setTerminating(){this.isTerminating=!0,h("\u{1F6D1}","Checkpoint manager marked as terminating")}markAncestorFinished(e){this.finishedAncestors.add(e)}getParentId(e){let t=e.lastIndexOf("-");return t>0?e.substring(0,t):void 0}hasFinishedAncestor(e){let t=this.getParentId(e);for(;t;){if(this.finishedAncestors.has(t))return!0;t=this.getParentId(t)}return!1}async forceCheckpoint(){return this.isTerminating?(h("\u26A0\uFE0F","Force checkpoint skipped - termination in progress"),new Promise(()=>{})):new Promise((e,t)=>{this.forceCheckpointPromises.push({resolve:e,reject:t}),this.isProcessing||setImmediate(()=>{this.processQueue()})})}async waitForQueueCompletion(){if(!(this.queue.length===0&&!this.isProcessing))return new Promise(e=>{this.queueCompletionResolver=e})}clearQueue(){this.queue=[],this.forceCheckpointPromises=[],this.notifyQueueCompletion()}async force(){return this.forceCheckpoint()}async checkpoint(e,t){return this.isTerminating?(h("\u26A0\uFE0F","Checkpoint skipped - termination in progress:",{stepId:e}),new Promise(()=>{})):this.hasFinishedAncestor(e)?(h("\u26A0\uFE0F","Checkpoint skipped - ancestor already finished:",{stepId:e}),new Promise(()=>{})):new Promise((n,a)=>{let i={stepId:e,data:t,resolve:()=>{n()},reject:o=>{a(o)}};this.queue.push(i),h("\u{1F4E5}","Checkpoint queued:",{stepId:e,queueLength:this.queue.length,isProcessing:this.isProcessing}),this.isProcessing||setImmediate(()=>{this.processQueue()})})}classifyCheckpointError(e){let t=e instanceof Error?e:new Error(String(e)),n=e,a=n.$metadata?.httpStatusCode,i=n.name,o=n.message||t.message;return h("\u{1F50D}","Classifying checkpoint error:",{statusCode:a,errorName:i,errorMessage:o}),a&&a>=400&&a<500&&i==="InvalidParameterValueException"&&o.startsWith("Invalid Checkpoint Token")?new ie(`Checkpoint failed: ${o}`,t):a&&a>=400&&a<500&&a!==429?new pe(`Checkpoint failed: ${o}`,t):new ie(`Checkpoint failed: ${o}`,t)}async processQueue(){if(this.isProcessing)return;let e=this.queue.length>0,t=this.forceCheckpointPromises.length>0;if(!e&&!t)return;this.isProcessing=!0;let n=[],i=this.currentTaskToken.length+100;for(;this.queue.length>0;){let o=this.queue[0],l=r.textEncoder.encode(JSON.stringify(o)).length;if(i+l>this.MAX_PAYLOAD_SIZE&&n.length>0)break;this.queue.shift(),n.push(o),i+=l}h("\u{1F504}","Processing checkpoint batch:",{batchSize:n.length,remainingInQueue:this.queue.length,estimatedSize:i,maxSize:this.MAX_PAYLOAD_SIZE});try{(n.length>0||this.forceCheckpointPromises.length>0)&&await this.processBatch(n),n.forEach(l=>{l.resolve()});let o=this.forceCheckpointPromises.splice(0);o.forEach(l=>{l.resolve()}),h("\u2705","Checkpoint batch processed successfully:",{batchSize:n.length,forceRequests:o.length,newTaskToken:this.currentTaskToken})}catch(o){h("\u274C","Checkpoint batch failed:",{batchSize:n.length,error:o});let l=this.classifyCheckpointError(o);this.clearQueue(),this.terminationManager.terminate({reason:L.CHECKPOINT_FAILED,message:l.message,error:l})}finally{this.isProcessing=!1,this.queue.length>0?setImmediate(()=>{this.processQueue()}):this.notifyQueueCompletion()}}notifyQueueCompletion(){this.queueCompletionResolver&&(this.queueCompletionResolver(),this.queueCompletionResolver=null)}async processBatch(e){let t=e.map(i=>{let o=G(i.stepId);return{Type:i.data.Type||"STEP",Action:i.data.Action||"START",...i.data,Id:o,...i.data.ParentId&&{ParentId:G(i.data.ParentId)}}}),n={DurableExecutionArn:this.durableExecutionArn,CheckpointToken:this.currentTaskToken,Updates:t};h("\u23FA\uFE0F","Creating checkpoint batch:",{batchSize:t.length,checkpointToken:this.currentTaskToken,updates:t.map(i=>({Id:i.Id,Action:i.Action,Type:i.Type}))});let a=await this.storage.checkpoint(n,this.logger);a.CheckpointToken&&(this.currentTaskToken=a.CheckpointToken),a.NewExecutionState?.Operations&&this.updateStepDataFromCheckpointResponse(a.NewExecutionState.Operations)}updateStepDataFromCheckpointResponse(e){h("\u{1F504}","Updating stepData from checkpoint response:",{operationCount:e.length,operationIds:e.map(t=>t.Id).filter(Boolean)}),e.forEach(t=>{if(t.Id){let n=this.stepData[t.Id]?.Status,a=t.Status;this.stepData[t.Id]=t,h("\u{1F4DD}","Updated stepData entry:",t),this.stepDataEmitter.emit(Tt,t.Id),n!==a&&this.resolveWaitingOperation(t.Id)}}),h("\u2705","StepData update completed:",{totalStepDataEntries:Object.keys(this.stepData).length})}resolveWaitingOperation(e){for(let[t,n]of this.operations.entries())if(G(t)===e&&n.resolver){h("\u2705",`Resolving waiting operation ${t} due to status change`),n.resolver(),n.resolver=void 0,n.timer&&(clearTimeout(n.timer),n.timer=void 0);break}}getQueueStatus(){return{queueLength:this.queue.length,isProcessing:this.isProcessing}}markOperationState(e,t,n){let a=this.operations.get(e);if(a)a.state=t,n?.endTimestamp!==void 0&&(a.endTimestamp=n.endTimestamp);else{if(!n?.metadata)throw new Error(`metadata required on first call for ${e}`);a={stepId:e,state:t,metadata:n.metadata,endTimestamp:n.endTimestamp},this.operations.set(e,a)}t===D.COMPLETED&&this.cleanupOperation(e),t!==D.IDLE_NOT_AWAITED&&this.checkAndTerminate()}waitForRetryTimer(e){let t=this.operations.get(e);if(!t)throw new Error(`Operation ${e} not found`);if(t.state!==D.RETRY_WAITING)throw new Error(`Operation ${e} must be in RETRY_WAITING state, got ${t.state}`);return this.startTimerWithPolling(e,t.endTimestamp),new Promise(n=>{t.resolver=n})}waitForStatusChange(e){let t=this.operations.get(e);if(!t)throw new Error(`Operation ${e} not found`);if(t.state!==D.IDLE_AWAITED)throw new Error(`Operation ${e} must be in IDLE_AWAITED state, got ${t.state}`);return this.startTimerWithPolling(e,t.endTimestamp),new Promise(n=>{t.resolver=n})}markOperationAwaited(e){let t=this.operations.get(e);if(!t){h("\u26A0\uFE0F",`Cannot mark operation as awaited: ${e} not found`);return}t.state===D.IDLE_NOT_AWAITED&&(t.state=D.IDLE_AWAITED,h("\u{1F4CD}",`Operation marked as awaited: ${e}`),this.checkAndTerminate())}getOperationState(e){return this.operations.get(e)?.state}getAllOperations(){return new Map(this.operations)}cleanupOperation(e){let t=this.operations.get(e);t&&(t.timer&&(clearTimeout(t.timer),t.timer=void 0),t.resolver=void 0)}cleanupAllOperations(){for(let e of this.operations.values())e.timer&&(clearTimeout(e.timer),e.timer=void 0),e.resolver=void 0}checkAndTerminate(){if(this.queue.length>0){this.abortTermination();return}if(this.isProcessing){this.abortTermination();return}if(this.forceCheckpointPromises.length>0){this.abortTermination();return}let e=Array.from(this.operations.values());if(e.some(i=>i.state===D.EXECUTING)){this.abortTermination();return}for(let i of e)if(i.state===D.RETRY_WAITING||i.state===D.IDLE_NOT_AWAITED||i.state===D.IDLE_AWAITED){let o=i.metadata.stepId;this.hasFinishedAncestor(o)&&(h("\u{1F9F9}",`Cleaning up operation with completed ancestor: ${o}`),this.cleanupOperation(i.stepId),this.operations.delete(i.stepId))}let n=Array.from(this.operations.values());if(n.some(i=>i.state===D.RETRY_WAITING||i.state===D.IDLE_NOT_AWAITED||i.state===D.IDLE_AWAITED)){let i=this.determineTerminationReason(n);this.scheduleTermination(i)}else this.abortTermination()}abortTermination(){this.terminationTimer&&(clearTimeout(this.terminationTimer),this.terminationTimer=null,this.terminationReason=null,h("\u{1F504}","Termination aborted - conditions changed"))}scheduleTermination(e){this.terminationTimer&&this.terminationReason===e||(this.abortTermination(),this.terminationReason=e,h("\u23F1\uFE0F","Scheduling termination",{reason:e,cooldownMs:this.TERMINATION_COOLDOWN_MS}),this.terminationTimer=setTimeout(()=>{this.executeTermination(e)},this.TERMINATION_COOLDOWN_MS))}executeTermination(e){h("\u{1F6D1}","Executing termination after cooldown",{reason:e}),this.terminationTimer=null,this.terminationReason=null,this.cleanupAllOperations(),this.terminationManager.terminate({reason:e})}determineTerminationReason(e){return e.some(t=>t.state===D.RETRY_WAITING&&t.metadata.subType==="Step")?L.RETRY_SCHEDULED:e.some(t=>(t.state===D.IDLE_NOT_AWAITED||t.state===D.IDLE_AWAITED)&&t.metadata.subType==="Wait")?L.WAIT_SCHEDULED:L.CALLBACK_PENDING}startTimerWithPolling(e,t){let n=this.operations.get(e);if(!n)return;let a;if(t){let i=t instanceof Date?t:new Date(t);a=Math.max(0,i.getTime()-Date.now())}else a=1e3;n.pollCount||(n.pollCount=0,n.pollStartTime=Date.now()),n.timer=setTimeout(()=>{this.forceRefreshAndCheckStatus(e)},a)}async forceRefreshAndCheckStatus(e){let t=this.operations.get(e);if(!t)return;let n=900*1e3;if(t.pollStartTime&&Date.now()-t.pollStartTime>n){h("\u23F1\uFE0F",`Max polling duration (15 min) exceeded for ${e}, stopping poll`),t.timer&&(clearTimeout(t.timer),t.timer=void 0);return}let a=this.stepData[G(e)]?.Status;await this.forceCheckpoint();let i=this.stepData[G(e)]?.Status;if(i!==a)h("\u2705",`Status changed for ${e}: ${a} \u2192 ${i}`),t.resolver?.(),t.resolver=void 0,t.timer&&(clearTimeout(t.timer),t.timer=void 0);else{t.pollCount=(t.pollCount||0)+1;let o=Math.min(t.pollCount*1e3,1e4);t.timer=setTimeout(()=>{this.forceRefreshAndCheckStatus(e)},o)}}},fe=class extends Ie{isTerminated=!1;terminationDetails;resolveTermination;terminationPromise;setCheckpointTerminating;constructor(e){super(),this.setCheckpointTerminating=e,this.terminationPromise=new Promise(t=>{this.resolveTermination=t})}setCheckpointTerminatingCallback(e){this.setCheckpointTerminating=e}terminate(e={}){this.isTerminated||(this.setCheckpointTerminating?.(),this.isTerminated=!0,this.terminationDetails={reason:e.reason??L.OPERATION_TERMINATED,message:e.message??"Operation terminated",error:e.error,cleanup:e.cleanup},this.resolveTermination&&this.handleTermination(this.terminationDetails).then(this.resolveTermination))}getTerminationPromise(){return this.terminationPromise}async handleTermination(e){if(e.cleanup)try{await e.cleanup()}catch{}return{reason:e.reason,message:e.message,error:e.error}}};function yt(r,e){return e instanceof Error?Object.assign({errorType:e?.constructor?.name??"UnknownError",errorMessage:e.message,stackTrace:typeof e.stack=="string"?e.stack.split(`
`):e.stack},e):e}function Z(r,e,...t){let n={requestId:e.requestId,timestamp:new Date().toISOString(),level:r.toUpperCase(),executionArn:e.executionArn},a=e.tenantId;if(a!=null&&a!=null&&(n.tenantId=a),e.operationId!==void 0&&(n.operationId=e.operationId),e.attempt!==void 0&&(n.attempt=e.attempt),t.length===1){n.message=t[0];try{return JSON.stringify(n,yt)}catch{return n.message=Se.format(n.message),JSON.stringify(n)}}n.message=Se.format(...t);for(let i of t)if(i instanceof Error){n.errorType=i?.constructor?.name??"UnknownError",n.errorMessage=i.message,n.stackTrace=typeof i.stack=="string"?i.stack.split(`
`):[];break}return JSON.stringify(n)}var ge=class{consoleLogger;durableLoggingContext=void 0;executionContext;noOpLog=()=>{};constructor(e){this.executionContext=e,this.consoleLogger=new ze({stdout:process.stdout,stderr:process.stderr}),this.info=this.noOpLog,this.error=this.noOpLog,this.warn=this.noOpLog,this.debug=this.noOpLog,this.configureLogLevel()}configureLogLevel(){let e={DEBUG:{name:"DEBUG",priority:2},INFO:{name:"INFO",priority:3},WARN:{name:"WARN",priority:4},ERROR:{name:"ERROR",priority:5}},t=process.env.AWS_LAMBDA_LOG_LEVEL?.toUpperCase(),n=t&&t in e?e[t]:e.DEBUG;e.DEBUG.priority>=n.priority&&(this.debug=(a,...i)=>{let o=this.ensureDurableLoggingContext(),l=a!==void 0?[a,...i]:i;this.consoleLogger.debug(Z(F.DEBUG,o.getDurableLogData(),...l))}),e.INFO.priority>=n.priority&&(this.info=(a,...i)=>{let o=this.ensureDurableLoggingContext(),l=a!==void 0?[a,...i]:i;this.consoleLogger.info(Z(F.INFO,o.getDurableLogData(),...l))}),e.WARN.priority>=n.priority&&(this.warn=(a,...i)=>{let o=this.ensureDurableLoggingContext(),l=a!==void 0?[a,...i]:i;this.consoleLogger.warn(Z(F.WARN,o.getDurableLogData(),...l))}),e.ERROR.priority>=n.priority&&(this.error=(a,...i)=>{let o=this.ensureDurableLoggingContext(),l=a!==void 0?[a,...i]:i;this.consoleLogger.error(Z(F.ERROR,o.getDurableLogData(),...l))})}ensureDurableLoggingContext(){let e=this.executionContext;if(!this.durableLoggingContext&&!e)throw new Error("DurableLoggingContext is not configured. Please call configureDurableLoggingContext before logging.");if(this.durableLoggingContext)return this.durableLoggingContext;if(!e)throw new Error("Execution context is not provided.");return{getDurableLogData:()=>({requestId:e.requestId,executionArn:e.durableExecutionArn,tenantId:e.tenantId})}}log(e,t,...n){switch(e){case F.DEBUG:this.debug(t,...n);break;case F.INFO:this.info(t,...n);break;case F.WARN:this.warn(t,...n);break;case F.ERROR:this.error(t,...n);break;default:this.info(t,...n);break}}info;error;warn;debug;configureDurableLoggingContext(e){this.durableLoggingContext=e}},Ce=r=>new ge(r),se,Te=class{client;constructor(e){e?this.client=e:(se||(se=new ve({requestHandler:{connectionTimeout:5e3,socketTimeout:5e4,requestTimeout:55e3,throwOnRequestTimeout:!0}})),this.client=se)}async getExecutionState(e,t){try{return await this.client.send(new We({DurableExecutionArn:e.DurableExecutionArn,CheckpointToken:e.CheckpointToken,Marker:e.Marker,MaxItems:e.MaxItems}))}catch(n){throw h("\u274C","GetDurableExecutionState failed",{error:n,requestId:n?.$metadata?.requestId,DurableExecutionArn:e.DurableExecutionArn,CheckpointToken:e.CheckpointToken,Marker:e.Marker}),t&&t.error("Failed to get durable execution state",n,{requestId:n?.$metadata?.requestId}),n}}async checkpoint(e,t){try{return await this.client.send(new $e({DurableExecutionArn:e.DurableExecutionArn,CheckpointToken:e.CheckpointToken,ClientToken:e.ClientToken,Updates:e.Updates}))}catch(n){throw h("\u274C","CheckpointDurableExecution failed",{error:n,requestId:n?.$metadata?.requestId,DurableExecutionArn:e.DurableExecutionArn,CheckpointToken:e.CheckpointToken,ClientToken:e.ClientToken}),t&&t.error("Failed to checkpoint durable execution",n,{requestId:n?.$metadata?.requestId}),n}}},ye=class r{durableExecutionClient;InitialExecutionState;DurableExecutionArn;CheckpointToken;constructor(e,t){this.durableExecutionClient=t,this.InitialExecutionState=e.InitialExecutionState,this.DurableExecutionArn=e.DurableExecutionArn,this.CheckpointToken=e.CheckpointToken}static isInstance(e){return e instanceof r?!0:!!(typeof e=="object"&&e&&e.toString()==="[object DurableExecutionInvocationInputWithClient]"&&"durableExecutionClient"in e&&e.constructor.name==="DurableExecutionInvocationInputWithClient")}get[Symbol.toStringTag](){return"DurableExecutionInvocationInputWithClient"}},Dt=async(r,e,t)=>{h("\u{1F535}","Initializing durable function with event:",r),h("\u{1F4CD}","Function Input:",r);let n=r.CheckpointToken,a=r.DurableExecutionArn,i=ye.isInstance(r)?r.durableExecutionClient:new Te(t),o=Ce({durableExecutionArn:a,requestId:e.awsRequestId,tenantId:e.tenantId}),l=[...r.InitialExecutionState.Operations||[]],u=r.InitialExecutionState.NextMarker;for(;u;){let d=await i.getExecutionState({CheckpointToken:n,Marker:u,DurableExecutionArn:a,MaxItems:1e3},o);l.push(...d.Operations||[]),u=d.NextMarker||""}let c=l.length>1?k.ReplayMode:k.ExecutionMode;h("\u{1F4DD}","Operations:",l);let p=l.reduce((d,s)=>(s.Id&&(d[s.Id]=s),d),{});return h("\u{1F4DD}","Loaded step data:",p),{executionContext:{durableExecutionClient:i,_stepData:p,terminationManager:new fe,durableExecutionArn:a,pendingCompletions:new Set,getStepData(d){return Ct(p,d)},tenantId:e.tenantId,requestId:e.awsRequestId},durableExecutionMode:c,checkpointToken:n}},xe=6*1024*1024-50;async function St(r,e,t,n,a,i){let o=new Ie,l=new Ee(t.durableExecutionArn,t._stepData,t.durableExecutionClient,t.terminationManager,a,o,Ce(t),new Set);t.terminationManager.setCheckpointTerminatingCallback(()=>{l.setTerminating()});let u={checkpointManager:l,stepDataEmitter:o,setTerminating:()=>l.setTerminating()},c=Le(t,e,n,Ce(),void 0,u),p=r.InitialExecutionState.Operations?.[0],d=JSON.parse(p?.ExecutionDetails?.InputPayload??"{}");try{h("\u{1F3AF}",`Starting handler execution, handler event: ${d}`);let s=!1,E=!1,f=V("root",void 0,()=>i(d,c)).then(S=>(s=!0,h("\u{1F3C6}","Handler promise resolved first!"),["handler",S])),m=t.terminationManager.getTerminationPromise().then(S=>(E=!0,h("\u{1F4A5}","Termination promise resolved first!"),u.setTerminating(),["termination",S]));setTimeout(()=>{h("\u23F1\uFE0F","Promise race status check:",{handlerResolved:s,terminationResolved:E})},500);let[g,x]=await Promise.race([f,m]);h("\u{1F3C1}","Promise race completed with:",{resultType:g});try{await u.checkpointManager.waitForQueueCompletion(),h("\u2705","All pending checkpoints completed")}catch(S){h("\u26A0\uFE0F","Error waiting for checkpoint completion:",S)}if(g==="termination"&&x.reason===L.CHECKPOINT_FAILED)throw h("\u{1F6D1}","Checkpoint failed - handling termination"),x.error;if(g==="termination"&&x.reason===L.SERDES_FAILED)throw h("\u{1F6D1}","Serdes failed - terminating Lambda execution"),new ue(x.message);if(g==="termination"&&x.reason===L.CONTEXT_VALIDATION_ERROR)return h("\u{1F6D1}","Context validation error - returning FAILED status"),{Status:z.FAILED,Error:_(x.error||new Error(x.message))};if(g==="termination")return h("\u{1F6D1}","Returning termination response"),{Status:z.PENDING};h("\u2705","Returning normal completion response");let T=JSON.stringify(x),C=new TextEncoder().encode(T).length;if(T&&C>xe){h("\u{1F4E6}",`Response size (${C} bytes) exceeds Lambda limit (${xe} bytes). Checkpointing result.`);let S=`execution-result-${Date.now()}`;try{await u.checkpointManager.checkpoint(S,{Id:S,Action:"SUCCEED",Type:w.EXECUTION,Payload:T}),h("\u2705","Large result successfully checkpointed");try{await u.checkpointManager.waitForQueueCompletion()}catch(A){h("\u26A0\uFE0F","Error waiting for checkpoint queue completion:",A)}return{Status:z.SUCCEEDED,Result:""}}catch(A){throw h("\u274C","Failed to checkpoint large result:",A),A}}try{await u.checkpointManager.waitForQueueCompletion()}catch(S){h("\u26A0\uFE0F","Error waiting for checkpoint queue completion:",S)}return{Status:z.SUCCEEDED,Result:T}}catch(s){if(h("\u274C","Handler threw an error:",s),Ye(s))throw h("\u{1F6D1}","Unrecoverable invocation error - terminating Lambda execution"),s;try{await u.checkpointManager.waitForQueueCompletion()}catch(E){h("\u26A0\uFE0F","Error waiting for checkpoint queue completion:",E)}return{Status:z.FAILED,Error:_(s)}}}function wt(r){try{let e=r;if(!e?.DurableExecutionArn||!e?.CheckpointToken)throw new Error("Missing required durable execution fields")}catch{let e=`Unexpected payload provided to start the durable execution. 
Check your resource configurations to confirm the durability is set.`;throw new Error(e)}}var Ne=(r,e)=>async(t,n)=>{wt(t);let{executionContext:a,durableExecutionMode:i,checkpointToken:o}=await Dt(t,n,e?.client),l=null;try{return l=await St(t,n,a,i,o,r),l}catch(u){throw u}},Ot={maxAttempts:60,initialDelay:{seconds:5},maxDelay:{seconds:300},backoffRate:1.5,jitter:$.FULL,timeoutSeconds:void 0};var At=async(r,e)=>{let{email:t}=r;return{success:!0,externalResult:await e.waitForCallback("wait-for-external-api",async(a,i)=>{i.logger?.info(`Submitting callback ID to external service: ${a}`);let o=await De({email:t,taskToken:a});console.log("durable-handler result",o)},{timeout:{minutes:15},heartbeatTimeout:{minutes:1}})}},$t=Ne(At);export{At as handler,$t as lambdaHandler};
